## In order to use a custom Kicker.Monitoring configuration, create a copy of 
## this file and modify it according to your needs. 
##
## The location of the file is passed to Kicker.Monitoring via the JVM parameter
## kicker.monitoring.configuration. For example, with a configuration file named 
## my.kicker.monitoring.properties in the folder META-INF you would pass this location 
## to the JVM when starting your application:
##
##  java -Dkicker.monitoring.configuration=META-INF/my.kicker.monitoring.properties [...]
##
## If no configuration file is passed, Kicker tries to use a configuration file in
## META-INF/kicker.monitoring.properties
## If this also fails, a default configuration is being used according to the values in 
## this default file.

## The name of the Kicker instance.
kicker.monitoring.name=KIEKER

## Whether a debug mode is activated.
## This changes a few internal id generation mechanisms to enable 
## easier debugging. Additionally, it is possible to enable debug 
## logging in the settings of the used logger. 
## This setting should usually not be set to true. 
kicker.monitoring.debug=false

## Enable/disable monitoring after startup (true|false; default: true)
## If monitoring is disabled, the MonitoringController simply pauses.
## Furthermore, probes should stop collecting new data and monitoring 
## writers stop should stop writing existing data.
kicker.monitoring.enabled=true

## The name of the VM running Kicker. If empty the name will be determined 
## automatically, else it will be set to the given value.
kicker.monitoring.hostname=

## The initial ID associated with all experiments. (currently not used)
kicker.monitoring.initialExperimentId=1

## Automatically add a metadata record to the monitoring log when writing
## the first monitoring record. The metadata record contains infromation 
## on the configuration of the monitoring controller.
kicker.monitoring.metadata=true

## Enables/disable the automatic assignment of each record's logging timestamp.
## (true|false; default: true) 
kicker.monitoring.setLoggingTimestamp=true

## Whether a shutdown hook should be registered.
## This ensures that necessary cleanup steps are finished and no 
## information is lost due to asynchronous writers.
## This should usually not be set to false.
kicker.monitoring.useShutdownHook=true

## Whether any JMX functionality is available
kicker.monitoring.jmx=false
kicker.monitoring.jmx.domain=kicker.monitoring

## Enable/Disable the MonitoringController MBean
kicker.monitoring.jmx.MonitoringController=true
kicker.monitoring.jmx.MonitoringController.name=MonitoringController

## Controls JMX remote access
kicker.monitoring.jmx.remote=false
kicker.monitoring.jmx.remote.port=59999
kicker.monitoring.jmx.remote.name=JMXServer
## If the SUN-JMX Bootstrap class is not available, a fallback to the 
## default implementation can be used. The fallback solution prevents 
## the VM from terminating.
## A graceful shutdown is done by connecting to the JMXServer, there to
## kicker.monitoring.JMXServer and using the operation stop()
kicker.monitoring.jmx.remote.fallback=true
## These properties will be forwarded to configure the JMX server
com.sun.management.jmxremote.local.only=false
com.sun.management.jmxremote.authenticate=false
com.sun.management.jmxremote.ssl=false

## The size of the thread pool used to execute registered periodic sensor jobs.
## The thread pool is also used to periodically read the config file for adaptive
## monitoring.
## Set to 0 to deactivate scheduling.
kicker.monitoring.periodicSensorsExecutorPoolSize=1

## Enable or disable adaptive monitoring.
kicker.monitoring.adaptiveMonitoring.enabled=false
#
## Default location of the adaptive monitoring configuration File
kicker.monitoring.adaptiveMonitoring.configFile=META-INF/kicker.monitoring.adaptiveMonitoring.conf
#
## Enable/disable the updating of the pattern file by activating or deactivating
## probes through the api.
kicker.monitoring.adaptiveMonitoring.updateConfigFile=false
#
## The delay in seconds in which the pattern file is checked for changes.
## Requires kicker.monitoring.periodicSensorsExecutorPoolSize > 0.
## Set to 0 to disable the observation.
kicker.monitoring.adaptiveMonitoring.readInterval=30


###########################
#######    TIMER    #######
###########################
## Selection of the timer used by Kicker (classname)
## The value must be a fully-qualified classname of a class implementing 
## kicker.monitoring.timer.ITimeSource and providing a constructor that 
## accepts a single Configuration. 
kicker.monitoring.timer=kicker.monitoring.timer.SystemNanoTimer

####
#kicker.monitoring.timer=kicker.monitoring.timer.SystemMilliTimer
#
## A timer with millisecond precision.
#
## The offset of the timer. The time returned is since 1970-1-1 
## minus this offset. If the offset is empty it is set to the current 
## time.
## The offset must be specified in milliseconds.
kicker.monitoring.timer.SystemMilliTimer.offset=0
## The timeunit used to report the timestamp. 
## Accepted values:
##  0 - nanoseconds
##  1 - microseconds
##  2 - milliseconds
##  3 - seconds 
kicker.monitoring.timer.SystemMilliTimer.unit=0

####
#kicker.monitoring.timer=kicker.monitoring.timer.SystemNanoTimer
#
## A timer with nanosecond precision.
#
## The offset of the timer. The time returned is since 1970-1-1 
## minus this offset. If the offset is empty it is set to the current 
## time.
## The offset must be specified in milliseconds.
kicker.monitoring.timer.SystemNanoTimer.offset=0
## The timeunit used to report the timestamp. 
## Accepted values:
##  0 - nanoseconds
##  1 - microseconds
##  2 - milliseconds
##  3 - seconds 
kicker.monitoring.timer.SystemNanoTimer.unit=0


###########################
#######    WRITER   #######
###########################
## Selection of monitoring data writer (classname)
## The value must be a fully-qualified classname of a class implementing 
## kicker.monitoring.writer.IMonitoringWriter and providing a constructor that 
## accepts a single Configuration. 
kicker.monitoring.writer=kicker.monitoring.writer.filesystem.AsyncFsWriter


#####
#kicker.monitoring.writer=kicker.monitoring.writer.DummyWriter
#
## Configuration Properties of the DummyWriter
kicker.monitoring.writer.DummyWriter.key=value


#####
#kicker.monitoring.writer=kicker.monitoring.writer.AsyncDummyWriter
#
## Configuration Properties of the AsyncDummyWriter
kicker.monitoring.writer.AsyncDummyWriter.key=value
#
## Asynchronous writers need to store monitoring records in an internal buffer.
## This parameter defines its capacity in terms of the number of records. 
kicker.monitoring.writer.AsyncDummyWriter.QueueSize=10000
#
## Behavior of the asynchronous writer when the internal queue is full:
## 0: terminate Monitoring with an error (default)
## 1: writer blocks until queue capacity is available
## 2: writer discards new records until space is available
##  Be careful when using the value '1' since then, the asynchronous writer
##  is no longer decoupled from the monitored application.
kicker.monitoring.writer.AsyncDummyWriter.QueueFullBehavior=0
#
## Maximum time to wait for the writer threads to finish (in milliseconds).
## A MaxShutdownDelay of -1 means infinite waiting.
kicker.monitoring.writer.AsyncDummyWriter.MaxShutdownDelay=-1


#####
#kicker.monitoring.writer=kicker.monitoring.writer.PrintStreamWriter
#
## The PrintStream used to print the monitoring records.
## Either STDOUT or STDERR.
## Other values are used as a filenames for a target log file.
## You should use another writer instead of this writer for logging to files!
kicker.monitoring.writer.PrintStreamWriter.Stream=STDOUT


#####
#kicker.monitoring.writer=kicker.monitoring.writer.filesystem.SyncFsWriter
#
## In order to use a custom directory, set customStoragePath as desired. Examples:
## /var/kicker or C:\\KickerData (ensure the folder exists).
## Otherwise the default temporary directory will be used
kicker.monitoring.writer.filesystem.SyncFsWriter.customStoragePath=
#
## The maximal number of entries (records) per created file.
## Must be greater than zero.
kicker.monitoring.writer.filesystem.SyncFsWriter.maxEntriesInFile=25000
#
## The maximal file size of the generated monitoring log. Older files will be 
## deleted if this file size is exceeded. Given in MiB.
## At least one file will always remain, regardless of size!
## Use -1 to ignore this functionality. 
kicker.monitoring.writer.filesystem.SyncFsWriter.maxLogSize=-1
#
## The maximal number of log files generated. Older files will be 
## deleted if this number is exceeded.
## At least one file will always remain, regardless of size!
## Use -1 to ignore this functionality. 
kicker.monitoring.writer.filesystem.SyncFsWriter.maxLogFiles=-1
#
## When flushing is disabled, it could require a lot of records before
## finally any writing is done.
kicker.monitoring.writer.filesystem.SyncFsWriter.flush=true
#
## When flushing is disabled, records are buffered in memory before written.
## This setting configures the size of the used buffer in bytes.
kicker.monitoring.writer.filesystem.SyncFsWriter.bufferSize=8192


#####
#kicker.monitoring.writer=kicker.monitoring.writer.filesystem.AsyncFsWriter
#
## In order to use a custom directory, set customStoragePath as desired. Examples:
## /var/kicker or C:\\KickerData (ensure the folder exists).
## Otherwise the default temporary directory will be used
kicker.monitoring.writer.filesystem.AsyncFsWriter.customStoragePath=
#
## The maximal number of entries (records) per created file.
## Must be greater than zero.
kicker.monitoring.writer.filesystem.AsyncFsWriter.maxEntriesInFile=25000
#
## The maximal file size of the generated monitoring log. Older files will be 
## deleted if this file size is exceeded. Given in MiB.
## At least one file will always remain, regardless of size!
## Use -1 to ignore this functionality. 
kicker.monitoring.writer.filesystem.AsyncFsWriter.maxLogSize=-1
#
## The maximal number of log files generated. Older files will be 
## deleted if this number is exceeded.
## At least one file will always remain, regardless of size!
## Use -1 to ignore this functionality. 
kicker.monitoring.writer.filesystem.AsyncFsWriter.maxLogFiles=-1
#
## When flushing is disabled, it could require a lot of records before
## finally any writing is done.
kicker.monitoring.writer.filesystem.AsyncFsWriter.flush=true
#
## When flushing is disabled, records are buffered in memory before written.
## This setting configures the size of the used buffer in bytes.
kicker.monitoring.writer.filesystem.AsyncFsWriter.bufferSize=8192
#
## Asynchronous writers need to store monitoring records in an internal buffer.
## This parameter defines its capacity in terms of the number of records. 
kicker.monitoring.writer.filesystem.AsyncFsWriter.QueueSize=10000
#
## Behavior of the asynchronous writer when the internal queue is full:
## 0: terminate Monitoring with an error (default)
## 1: writer blocks until queue capacity is available
## 2: writer discards new records until space is available
##  Be careful when using the value '1' since then, the asynchronous writer
##  is no longer decoupled from the monitored application.
kicker.monitoring.writer.filesystem.AsyncFsWriter.QueueFullBehavior=0
#
## Maximum time to wait for the writer threads to finish (in milliseconds).
## A MaxShutdownDelay of -1 means infinite waiting.
kicker.monitoring.writer.filesystem.AsyncFsWriter.MaxShutdownDelay=-1


#####
#kicker.monitoring.writer=kicker.monitoring.writer.filesystem.AsyncBinaryFsWriter
#
## In order to use a custom directory, set customStoragePath as desired. Examples:
## /var/kicker or C:\\KickerData (ensure the folder exists).
## Otherwise the default temporary directory will be used
kicker.monitoring.writer.filesystem.AsyncBinaryFsWriter.customStoragePath=
#
## The maximal number of entries (records) per created file.
## Must be greater than zero.
kicker.monitoring.writer.filesystem.AsyncBinaryFsWriter.maxEntriesInFile=25000
#
## The maximal file size of the generated monitoring log. Older files will be 
## deleted if this file size is exceeded. Given in MiB.
## At least one file will always remain, regardless of size!
## Use -1 to ignore this functionality. 
kicker.monitoring.writer.filesystem.AsyncBinaryFsWriter.maxLogSize=-1
#
## The maximal number of log files generated. Older files will be 
## deleted if this number is exceeded.
## At least one file will always remain, regardless of size!
## Use -1 to ignore this functionality. 
kicker.monitoring.writer.filesystem.AsyncBinaryFsWriter.maxLogFiles=-1
#
## Whether the generated log files are compressed before writing to disk.
## Supported values are: NONE, DEFLATE, GZIP, ZIP
kicker.monitoring.writer.filesystem.AsyncBinaryFsWriter.compress=NONE
#
## Records are buffered in memory before written to disk.
## This setting configures the size of the used buffer in bytes.
kicker.monitoring.writer.filesystem.AsyncBinaryFsWriter.bufferSize=8192
#
## Asynchronous writers need to store monitoring records in an internal buffer.
## This parameter defines its capacity in terms of the number of records. 
kicker.monitoring.writer.filesystem.AsyncBinaryFsWriter.QueueSize=10000
#
## Behavior of the asynchronous writer when the internal queue is full:
## 0: terminate Monitoring with an error (default)
## 1: writer blocks until queue capacity is available
## 2: writer discards new records until space is available
##  Be careful when using the value '1' since then, the asynchronous writer
##  is no longer decoupled from the monitored application.
kicker.monitoring.writer.filesystem.AsyncBinaryFsWriter.QueueFullBehavior=0
#
## Maximum time to wait for the writer threads to finish (in milliseconds).
## A MaxShutdownDelay of -1 means infinite waiting.
kicker.monitoring.writer.filesystem.AsyncBinaryFsWriter.MaxShutdownDelay=-1


#####
#kicker.monitoring.writer=kicker.monitoring.writer.filesystem.AsyncBinaryNFsWriter
#
## In order to use a custom directory, set customStoragePath as desired. Examples:
## /var/kicker or C:\\KickerData (ensure the folder exists).
## Otherwise the default temporary directory will be used
kicker.monitoring.writer.filesystem.AsyncBinaryNFsWriter.customStoragePath=
#
## The maximal number of entries (records) per created file.
## Must be greater than zero.
kicker.monitoring.writer.filesystem.AsyncBinaryNFsWriter.maxEntriesInFile=25000
#
## The maximal file size of the generated monitoring log. Older files will be 
## deleted if this file size is exceeded. Given in MiB.
## At least one file will always remain, regardless of size!
## Use -1 to ignore this functionality. 
kicker.monitoring.writer.filesystem.AsyncBinaryNFsWriter.maxLogSize=-1
#
## The maximal number of log files generated. Older files will be 
## deleted if this number is exceeded.
## At least one file will always remain, regardless of size!
## Use -1 to ignore this functionality. 
kicker.monitoring.writer.filesystem.AsyncBinaryNFsWriter.maxLogFiles=-1
#
## Records are buffered in memory before written to disk.
## This setting configures the size of the used buffer in bytes.
kicker.monitoring.writer.filesystem.AsyncBinaryNFsWriter.bufferSize=65535
#
## Asynchronous writers need to store monitoring records in an internal buffer.
## This parameter defines its capacity in terms of the number of records. 
kicker.monitoring.writer.filesystem.AsyncBinaryNFsWriter.QueueSize=10000
#
## Behavior of the asynchronous writer when the internal queue is full:
## 0: terminate Monitoring with an error (default)
## 1: writer blocks until queue capacity is available
## 2: writer discards new records until space is available
##  Be careful when using the value '1' since then, the asynchronous writer
##  is no longer decoupled from the monitored application.
kicker.monitoring.writer.filesystem.AsyncBinaryNFsWriter.QueueFullBehavior=0
#
## Maximum time to wait for the writer threads to finish (in milliseconds).
## A MaxShutdownDelay of -1 means infinite waiting.
kicker.monitoring.writer.filesystem.AsyncBinaryNFsWriter.MaxShutdownDelay=-1


#####
#kicker.monitoring.writer=kicker.monitoring.writer.filesystem.AsyncAsciiZipWriter
#
## In order to use a custom directory, set customStoragePath as desired. Examples:
## /var/kicker or C:\\KickerData (ensure the folder exists).
## Otherwise the default temporary directory will be used
kicker.monitoring.writer.filesystem.AsyncAsciiZipWriter.customStoragePath=
#
## The maximal number of entries (records) per created file.
## Must be greater than zero.
kicker.monitoring.writer.filesystem.AsyncAsciiZipWriter.maxEntriesInFile=25000
#
## Records are buffered in memory before written to disk.
## This setting configures the size of the used buffer in bytes.
kicker.monitoring.writer.filesystem.AsyncAsciiZipWriter.bufferSize=8192
#
## Asynchronous writers need to store monitoring records in an internal buffer.
## This parameter defines its capacity in terms of the number of records. 
kicker.monitoring.writer.filesystem.AsyncAsciiZipWriter.QueueSize=10000
#
## Behavior of the asynchronous writer when the internal queue is full:
## 0: terminate Monitoring with an error (default)
## 1: writer blocks until queue capacity is available
## 2: writer discards new records until space is available
##  Be careful when using the value '1' since then, the asynchronous writer
##  is no longer decoupled from the monitored application.
kicker.monitoring.writer.filesystem.AsyncAsciiZipWriter.QueueFullBehavior=0
#
## Maximum time to wait for the writer threads to finish (in milliseconds).
## A MaxShutdownDelay of -1 means infinite waiting.
kicker.monitoring.writer.filesystem.AsyncAsciiZipWriter.MaxShutdownDelay=-1
#
## Sets the compression level. The only valid values are:
## -1: default compression
## 0: no compression
## 1-9: from best speed to best compression 
kicker.monitoring.writer.filesystem.AsyncAsciiZipWriter.compressionLevel=-1


#####
#kicker.monitoring.writer=kicker.monitoring.writer.filesystem.AsyncBinaryZipWriter
#
## In order to use a custom directory, set customStoragePath as desired. Examples:
## /var/kicker or C:\\KickerData (ensure the folder exists).
## Otherwise the default temporary directory will be used
kicker.monitoring.writer.filesystem.AsyncBinaryZipWriter.customStoragePath=
#
## The maximal number of entries (records) per created file.
## Must be greater than zero.
kicker.monitoring.writer.filesystem.AsyncBinaryZipWriter.maxEntriesInFile=25000
#
## Records are buffered in memory before written to disk.
## This setting configures the size of the used buffer in bytes.
kicker.monitoring.writer.filesystem.AsyncBinaryZipWriter.bufferSize=8192
#
## Asynchronous writers need to store monitoring records in an internal buffer.
## This parameter defines its capacity in terms of the number of records. 
kicker.monitoring.writer.filesystem.AsyncBinaryZipWriter.QueueSize=10000
#
## Behavior of the asynchronous writer when the internal queue is full:
## 0: terminate Monitoring with an error (default)
## 1: writer blocks until queue capacity is available
## 2: writer discards new records until space is available
##  Be careful when using the value '1' since then, the asynchronous writer
##  is no longer decoupled from the monitored application.
kicker.monitoring.writer.filesystem.AsyncBinaryZipWriter.QueueFullBehavior=0
#
## Maximum time to wait for the writer threads to finish (in milliseconds).
## A MaxShutdownDelay of -1 means infinite waiting.
kicker.monitoring.writer.filesystem.AsyncBinaryZipWriter.MaxShutdownDelay=-1
#
## Sets the compression level. The only valid values are:
## -1: default compression
## 0: no compression
## 1-9: from best speed to best compression 
kicker.monitoring.writer.filesystem.AsyncBinaryZipWriter.compressionLevel=-1


#####
#kicker.monitoring.writer=kicker.monitoring.writer.namedRecordPipe.PipeWriter
#
## The name of the pipe used (must not be empty).
kicker.monitoring.writer.namedRecordPipe.PipeWriter.pipeName=kicker-pipe


#####
#kicker.monitoring.writer=kicker.monitoring.writer.jms.AsyncJMSWriter
#
## The url of the jndi provider that knows the jms service
## - ActiveMQ: tcp://127.0.0.1:61616/
## - HornetQ:  jnp://localhost:1099/
## - OpenJMS:  tcp://127.0.0.1:3035/
kicker.monitoring.writer.jms.AsyncJMSWriter.ProviderUrl=tcp://127.0.0.1:61616/
#
## The topic at the jms server which is used in the publisher/subscribe communication.
kicker.monitoring.writer.jms.AsyncJMSWriter.Topic=queue1
#
## The type of the jms factory implementation, e.g.
## - ActiveMQ: org.apache.activemq.jndi.ActiveMQInitialContextFactory
## - HornetQ:  org.jnp.interfaces.NamingContextFactory
## - OpenJMS:  org.exolab.jms.jndi.InitialContextFactory
kicker.monitoring.writer.jms.AsyncJMSWriter.ContextFactoryType=org.apache.activemq.jndi.ActiveMQInitialContextFactory
#
## The service name for the jms connection factory.
kicker.monitoring.writer.jms.AsyncJMSWriter.FactoryLookupName=ConnectionFactory
#
## The time that a jms message will be kept alive at the jms server before 
## it is automatically deleted.
kicker.monitoring.writer.jms.AsyncJMSWriter.MessageTimeToLive=10000
#
## Asynchronous writers need to store monitoring records in an internal buffer.
## This parameter defines its capacity in terms of the number of records. 
kicker.monitoring.writer.jms.AsyncJMSWriter.QueueSize=10000
#
## Behavior of the asynchronous writer when the internal queue is full:
## 0: terminate Monitoring with an error (default)
## 1: writer blocks until queue capacity is available
## 2: writer discards new records until space is available
##  Be careful when using the value '1' since then, the asynchronous writer
##  is no longer decoupled from the monitored application.
kicker.monitoring.writer.jms.AsyncJMSWriter.QueueFullBehavior=0
#
## Maximum time to wait for the writer threads to finish (in milliseconds).
## A MaxShutdownDelay of -1 means infinite waiting.
kicker.monitoring.writer.jms.AsyncJMSWriter.MaxShutdownDelay=-1


#####
#kicker.monitoring.writer=kicker.monitoring.writer.database.SyncDbWriter
#
## Database driver classname
## Examples:
##   MySQL:   com.mysql.jdbc.Driver
##   DerbyDB: org.apache.derby.jdbc.EmbeddedDriver
kicker.monitoring.writer.database.SyncDbWriter.DriverClassname=org.apache.derby.jdbc.EmbeddedDriver
#
## Connection string
## Examples:
##   MySQL:   jdbc:mysql://HOSTNAME/DBNAME?user=DBUSER&password=DBPASS
##   DerbyDB: jdbc:derby:DBNAME;user=DBUSER;password=DBPASS
kicker.monitoring.writer.database.SyncDbWriter.ConnectionString=jdbc:derby:tmp/KIEKER;user=DBUSER;password=DBPASS;create=true
#
## Prefix for the names of the database tables
kicker.monitoring.writer.database.SyncDbWriter.TablePrefix=kicker
#
## Drop already existing tables or terminate monitoring with an error. 
kicker.monitoring.writer.database.SyncDbWriter.DropTables=false


#####
#kicker.monitoring.writer=kicker.monitoring.writer.database.AsyncDbWriter
#
## Database driver classname
##   MySQL:   com.mysql.jdbc.Driver
##   DerbyDB: org.apache.derby.jdbc.EmbeddedDriver
kicker.monitoring.writer.database.AsyncDbWriter.DriverClassname=org.apache.derby.jdbc.EmbeddedDriver
#
## Connection string
## Examples:
##   MySQL:   jdbc:mysql://HOSTNAME/DBNAME?user=DBUSER&password=DBPASS
##   DerbyDB: jdbc:derby:DBNAME;user=DBUSER;password=DBPASS
kicker.monitoring.writer.database.AsyncDbWriter.ConnectionString=jdbc:derby:tmp/KIEKER;user=DBUSER;password=DBPASS;create=true
#
## Prefix for the names of the database tables
kicker.monitoring.writer.database.AsyncDbWriter.TablePrefix=kicker
#
## Drop already existing tables or terminate monitoring with an error. 
kicker.monitoring.writer.database.AsyncDbWriter.DropTables=false
#
## The number of concurrent Database connections.
kicker.monitoring.writer.database.AsyncDbWriter.numberOfConnections=4
#
## Asynchronous writers need to store monitoring records in an internal buffer.
## This parameter defines its capacity in terms of the number of records. 
kicker.monitoring.writer.database.AsyncDbWriter.QueueSize=10000
#
## Behavior of the asynchronous writer when the internal queue is full:
## 0: terminate Monitoring with an error (default)
## 1: writer blocks until queue capacity is available
## 2: writer discards new records until space is available
##  Be careful when using the value '1' since then, the asynchronous writer
##  is no longer decoupled from the monitored application.
kicker.monitoring.writer.database.AsyncDbWriter.QueueFullBehavior=0
#
## Maximum time to wait for the writer threads to finish (in milliseconds).
## A MaxShutdownDelay of -1 means infinite waiting.
kicker.monitoring.writer.database.AsyncDbWriter.MaxShutdownDelay=-1


#####
#kicker.monitoring.writer=kicker.monitoring.writer.jmx.JMXWriter
#
## The domain used to register the MonitoringLog. If empty, the value
## of "kicker.monitoring.jmx.domain" will be used.
kicker.monitoring.writer.jmx.JMXWriter.domain=
#
## The name of the MonitoringLog in the domain.
kicker.monitoring.writer.jmx.JMXWriter.logname=MonitoringLog


#####
#kicker.monitoring.writer=kicker.monitoring.writer.tcp.TCPWriter
#
## The hostname the TCPWriter connects to.
kicker.monitoring.writer.tcp.TCPWriter.hostname=localhost
#
## The ports the TCPWriter connects to.
kicker.monitoring.writer.tcp.TCPWriter.port1=10133
kicker.monitoring.writer.tcp.TCPWriter.port2=10134
#
## The size of the buffer used by the TCPWriter in bytes.
## Should be large enough to fit at least single string records (> 1KiB).
kicker.monitoring.writer.tcp.TCPWriter.bufferSize=65535
#
## Should each record be immediately sent?
kicker.monitoring.writer.tcp.TCPWriter.flush=false
#
## Asynchronous writers need to store monitoring records in an internal buffer.
## This parameter defines its capacity in terms of the number of records. 
kicker.monitoring.writer.tcp.TCPWriter.QueueSize=10000
#
## Behavior of the asynchronous writer when the internal queue is full:
## 0: terminate Monitoring with an error (default)
## 1: writer blocks until queue capacity is available
## 2: writer discards new records until space is available
##  Be careful when using the value '1' since then, the asynchronous writer
##  is no longer decoupled from the monitored application.
kicker.monitoring.writer.tcp.TCPWriter.QueueFullBehavior=0
#
## Maximum time to wait for the writer threads to finish (in milliseconds).
## A MaxShutdownDelay of -1 means infinite waiting.
kicker.monitoring.writer.tcp.TCPWriter.MaxShutdownDelay=-1


#####
#kicker.monitoring.writer=kicker.monitoring.writer.explorviz.ExplorVizExportWriter
#
## The hostname the ExplorVizExportWriter connects to.
kicker.monitoring.writer.explorviz.ExplorVizExportWriter.hostname=localhost
#
## The ports the TCPWriter connects to.
kicker.monitoring.writer.explorviz.ExplorVizExportWriter.port=10133
#
## The size of the buffer used by the TCPWriter in bytes.
## Should be large enough to fit at least single string records (> 1KiB).
kicker.monitoring.writer.explorviz.ExplorVizExportWriter.bufferSize=65535
#
## Should each record be immediately sent?
kicker.monitoring.writer.explorviz.ExplorVizExportWriter.flush=false
#
## Asynchronous writers need to store monitoring records in an internal buffer.
## This parameter defines its capacity in terms of the number of records. 
kicker.monitoring.writer.explorviz.ExplorVizExportWriter.QueueSize=1000000
#
## Behavior of the asynchronous writer when the internal queue is full:
## 0: terminate Monitoring with an error
## 1: writer blocks until queue capacity is available (default)
## 2: writer discards new records until space is available
##  Be careful when using the value '1' since then, the asynchronous writer
##  is no longer decoupled from the monitored application.
kicker.monitoring.writer.explorviz.ExplorVizExportWriter.QueueFullBehavior=1
#
## Maximum time to wait for the writer threads to finish (in milliseconds).
## A MaxShutdownDelay of -1 means infinite waiting.
kicker.monitoring.writer.explorviz.ExplorVizExportWriter.MaxShutdownDelay=-1
